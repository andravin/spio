"""
Run all C++ unit tests as a single pytest test.

The C++ tests conver generated index and tensor classes. These classes
work in both C++ and CUDA programs.
"""

from subprocess import CalledProcessError
from tempfile import NamedTemporaryFile
import os
from typing import Callable

from importlib_resources import files as importlib_resources_files
import pytest

import spio.generators as gen
import spio.compiler


TRUTHS = ["true", "1", "yes", "y", "t"]

ENABLE_CPP_TESTS = os.environ.get("SPIO_ENABLE_CPP_TESTS", "false").lower() in TRUTHS

UTEST_HEADER = '#include "utest.h"'

TEST_MODULES = [
    gen.index,
    gen.tensor,
    gen.checkerboard,
    gen.fragment_index,
    gen.dim,
]

CPP_SOURCES = [
    "test_main.cpp",
    "test_tensor_variadic.cpp",
    "test_index_variadic.cpp",
    # "test_index.cpp",
    # "test_tensor.cpp",
    # "test_fragment_index.cpp",
    # "test_mathutil.cpp",
    # "test_strip_loader_params.cpp",
    "test_dim.cpp",
]

TEST_SOURCES = []


@pytest.mark.skipif(
    not ENABLE_CPP_TESTS, reason="NVCC support not required by default."
)
def test_cpp_tests():
    """Compile and run all C++ unit tests.

    This PyTest test will succeed if all C++ unit tests pass.
    Run tests with "pytest -s test_cpp.py" to see the detailed output.
    """
    test_headers = [getattr(module, "header")() for module in TEST_MODULES]

    code = "\n".join([UTEST_HEADER] + test_headers + TEST_SOURCES)
    test_source_file = NamedTemporaryFile(prefix="spio_", suffix=".cpp")
    with open(test_source_file.name, "w", encoding="utf-8") as f:
        f.write(code)
    try:
        _compile_cpp_tests([test_source_file.name])
    except CalledProcessError as e:
        assert False, f"{e.stdout} {e.stderr}"


def _cpp_test(func: Callable[[], str]):
    """Register the C++ source code generated by the given python function."""
    # XXX TEST_SOURCES.append(func())
    pass


@_cpp_test
def _test_generate_dim():
    """Return the C++ source code that tests a custom dimension class."""
    specs = [gen.Dim("i"), gen.Dim("j")]
    generated_code = gen.generate(specs, namespace="I_Dim_GenCode")
    return f"""
{generated_code}

UTEST(I_Dim, methods)
{{
    using namespace I_Dim_GenCode;
    EXPECT_EQ(I_Dim(7).get(), 7);
    EXPECT_TRUE(I_Dim(7) == I_Dim(7));
    EXPECT_TRUE(I_Dim(7) < I_Dim(8));
    EXPECT_TRUE(I_Dim(7) <= I_Dim(8));
    EXPECT_TRUE(I_Dim(8) > I_Dim(7));
    EXPECT_TRUE(I_Dim(8) >= I_Dim(7));
    EXPECT_TRUE(I_Dim(7) == I_Dim(7));
    EXPECT_TRUE(I_Dim(7) <= I_Dim(7));
    EXPECT_TRUE(I_Dim(7) >= I_Dim(7));
    EXPECT_TRUE(I_Dim(7) != I_Dim(8));
    EXPECT_TRUE(I_Dim(7) + I_Dim(8) == I_Dim(15));
    EXPECT_TRUE(I_Dim(8) - I_Dim(7) == I_Dim(1));
    EXPECT_TRUE(I_Dim(8) % I_Dim(3) == I_Dim(2));
    EXPECT_TRUE((I_Dim(32).fold<4>() == spio::Fold<I_Dim, 4>(8)));
    EXPECT_TRUE((I_Dim(32).cast<J_Dim>() == J_Dim(32)));
}}

UTEST(I_Dim, range)
{{
    using namespace I_Dim_GenCode;
    int j = 0;
    for (auto i : I_Dim(7)) {{
        EXPECT_EQ(i.get(), j++);
    }}
    EXPECT_EQ(j, 7);
}}
"""


@_cpp_test
def _test_generate_fold():
    specs = [
        gen.Dim("c"),
        gen.Fold("block_i", "i", 64),
        gen.Fold("block_j", "j", 64),
        gen.Fold("block_c8", "c8", 4),
    ]
    generated_code = gen.generate(specs, namespace="I_Fold_GenCode")
    return f"""
{generated_code}

UTEST(I_Fold, methods)
{{
    using namespace I_Fold_GenCode;
    EXPECT_EQ(BLOCK_I_Dim(7).get(), 7);
    EXPECT_TRUE(BLOCK_I_Dim(7).unfold() == I_Dim(7 * 64));
    EXPECT_TRUE((BLOCK_I_Dim(7).fold<32>() == spio::Fold<I_Dim, 32>(7 * 2)));

    EXPECT_EQ(BLOCK_C8_Dim(7).get(), 7);
    EXPECT_TRUE((BLOCK_C8_Dim(7).unfold() == spio::Fold<C_Dim, 8>(7 * 4)));

    EXPECT_TRUE(BLOCK_I_Dim(7).cast<J_Dim>() == BLOCK_J_Dim(7));
}}
"""


@_cpp_test
def _test_generate_index():
    """Return the C++ source code that tests a custom index class."""

    specs = [
        gen.Index("MyIndex", {"n": 4, "h": 32, "w": 64, "c": 128}),
    ]

    generated_code = gen.generate(specs, namespace="MyIndex_GenCode")
    size = 4 * 32 * 64 * 128
    test_code = f"""
{generated_code}

UTEST(MyIndex, index_from_offset)
{{
    using namespace MyIndex_GenCode;
    int offset = 532523;
    MyIndex idx(offset);
    EXPECT_TRUE(idx.n() == N_Dim(offset / (32 * 64 * 128) ) );
    EXPECT_TRUE(idx.h() == H_Dim( (offset / (64 * 128)) % 32) );
    EXPECT_TRUE(idx.w() == W_Dim( (offset / 128) % 64));
    EXPECT_TRUE(idx.c() == C_Dim(offset % 128));
}}

UTEST(MyIndex, size)
{{
    using namespace MyIndex_GenCode;
    EXPECT_EQ(MyIndex::size, {size});
}}

UTEST(MyIndex, dim_sizes)
{{
    using namespace MyIndex_GenCode;
    EXPECT_TRUE(MyIndex::N == N_Dim(4));
    EXPECT_TRUE(MyIndex::H == H_Dim(32));
    EXPECT_TRUE(MyIndex::W == W_Dim(64));
    EXPECT_TRUE(MyIndex::C == C_Dim(128));
}}
"""
    return test_code


@_cpp_test
def _test_generate_checkerboard_index():
    specs = [
        gen.Index(
            "MyCheckerboard", dict(c16=8, checkers=gen.CheckerboardIndex(r=16, c=2))
        ),
    ]
    generated_code = gen.generate(specs, namespace="IndexSpec_GenCode")
    code = f"""
{generated_code}

UTEST(IndexSpec, checkerboard_fused_dim)
{{
    using namespace IndexSpec_GenCode;
    EXPECT_EQ(MyCheckerboard::size, 8 * 16 * 2);
    EXPECT_TRUE((MyCheckerboard::C16 == spio::Fold<C_Dim, 16>(8)));
    EXPECT_EQ(MyCheckerboard::CHECKERS, 16 * 2);
    for (int offset = 0; offset < MyCheckerboard::size; ++offset) {{
        MyCheckerboard idx(offset);
        EXPECT_EQ(idx.c16().get(), offset / (16 * 2));
        int ckbd_offset = offset % 32;
        int ckbd_row = ckbd_offset / 8;
        EXPECT_TRUE(idx.checkers().r() == R_Dim(ckbd_offset / 2));
        EXPECT_TRUE(idx.checkers().c() == C_Dim((ckbd_offset & 1) ^ (ckbd_row & 1)));
    }}
}}
"""
    return code


@_cpp_test
def _test_generate_dense_tensor():
    """Return the C++ source code that tests a custom tensor class."""
    n = 7
    h = 16
    w = 33
    c = 42

    tensor_spec = gen.Tensor(
        "DenseTensor", gen.dtype.float, {"n": n, "h": h, "w": w, "c": c}
    )

    size = n * h * w * c
    assert tensor_spec.size == size
    assert tensor_spec.num_bytes == size * gen.dtype.float.value.size

    generated_code = gen.generate([tensor_spec], namespace="DenseTensor_GenCode")
    test_code = f"""

{generated_code}

UTEST(DenseTensor, offset_from_tensor)
{{
    using namespace DenseTensor_GenCode;
    constexpr int N = {n};
    constexpr int H = {h};
    constexpr int W = {w};
    constexpr int C = {c};
    constexpr int size = N * H * W *C;
    constexpr size_t num_bytes = sizeof(float) * size;

    float data[N * H * W * C];
    for (int n = 0; n < N; ++n) {{
        for (int h = 0; h < H; ++h) {{
            for (int w = 0; w < W; ++w) {{
                for (int c = 0; c < C; ++c) {{
                    data[n*(H*W*C) + h*(W*C) + w*C +c] = n*(H*W*C) + h*(W*C) + w*C + c;
                }}
            }}
        }}
    }}

    // Test the use of named-index accessors and subscript operators with the tensor class.
    // Note all permutations of the subscript operators are equivalent. Because the operator
    // is overloaded for dimension type, the order of the subscript operator does not matter.
    DenseTensor tensor(data);
    for (auto n : tensor.N) {{
        for (auto h : tensor.H) {{
            for (auto w : tensor.W) {{
                for (auto c : tensor.C) {{
                    EXPECT_EQ(*tensor.n(n).h(h).w(w).c(c), n.get()*(H*W*C) + h.get()*(W*C) + w.get()*C + c.get());
                    EXPECT_EQ(*tensor[n][h][w][c], n.get()*(H*W*C) + h.get()*(W*C) + w.get()*C + c.get());
                    EXPECT_EQ(*tensor[h][n][c][w], n.get()*(H*W*C) + h.get()*(W*C) + w.get()*C + c.get());
                    EXPECT_EQ(*tensor[h][w][c][n], n.get()*(H*W*C) + h.get()*(W*C) + w.get()*C + c.get());
                    EXPECT_EQ(*tensor[w][c][n][h], n.get()*(H*W*C) + h.get()*(W*C) + w.get()*C + c.get());
                }}
            }}
        }}
    }}

    // Test the use of an integer offset with the tensor offset method.
    for (int offset = 0; offset < size; ++offset) {{
        EXPECT_EQ(*tensor.offset(offset), data[offset]);
    }}

    // Test the use of a generated index class with the tensor subscript operator.
    for (int offset = 0; offset < size; ++offset) {{
        DenseTensor::Index idx(offset);
        EXPECT_EQ(*idx.offset_tensor(tensor), data[offset]);
        EXPECT_EQ(*tensor[idx], data[offset]);
    }}

    
    EXPECT_EQ(DenseTensor::size, size);
    EXPECT_EQ(DenseTensor::num_bytes, static_cast<int>(num_bytes));

    int nn = 0;
    for (auto n : DenseTensor::N) {{
        EXPECT_EQ(n.get(), nn++);
    }}
    EXPECT_EQ(nn, N);
}}
"""
    return test_code


@_cpp_test
def _test_genrate_1d_dense_tensor():
    """Return the C++ source code that tests a custom 1D tensor class"""
    n = 7
    specs = [
        gen.Tensor("DenseTensor", gen.dtype.float, {"n": n}, constant=True),
    ]
    generated_code = gen.generate(specs, namespace="DenseTensor_1D_GenCode")
    test_code = f"""

{generated_code}

UTEST(DensTensor1D, offset_from_tensor)
{{
    using namespace DenseTensor_1D_GenCode;
    constexpr int N = {n};
    constexpr int size = N;
    constexpr size_t num_bytes = sizeof(float) * size;

    float data[N];
    for (int n = 0; n < N; ++n) {{
        data[n] = n;
    }}
    for (auto n : DenseTensor::N) {{
        // Tensor named-index accessors.
        EXPECT_EQ(*DenseTensor(data).n(n), data[n.get()]);

        // Tensor subscript accessors.
        EXPECT_EQ(*DenseTensor(data)[n], data[n.get()]);
    }}
    EXPECT_EQ(DenseTensor::size, size);
    EXPECT_EQ(DenseTensor::num_bytes, static_cast<int>(num_bytes));
}}
"""
    return test_code


@_cpp_test
def _test_generate_tensor_with_strides():
    """Return the C++ source code that tests a custom tensor class."""
    n = 7
    h = 16
    w = 33
    c = 42

    stride_w = c + 2
    stride_h = (w + 1) * stride_w

    specs = [
        gen.Tensor(
            "StrideTensor",
            gen.dtype.float,
            gen.Dims(n=n, h=h, w=w, c=c),
            strides=gen.Strides(h=stride_h, w=stride_w),
            constant=True,
        ),
    ]
    generated_code = gen.generate(specs, namespace="StrideTensor_GenCode")
    test_code = f"""

{generated_code}

UTEST(StrideTensor, offset_from_tensor)
{{
    using namespace StrideTensor_GenCode;
    constexpr int N = {n};
    constexpr int H = {h};
    constexpr int W = {w};
    constexpr int C = {c};

    constexpr int stride_w = {stride_w};
    constexpr int stride_h = {stride_h};
    constexpr int stride_n = H * stride_h;
    constexpr int size = N * stride_n;
    constexpr size_t num_bytes = sizeof(float) * size;

    float data[N * stride_n];
    for (int n = 0; n < N; ++n) {{
        for (int h = 0; h < H; ++h) {{
            for (int w = 0; w < W; ++w) {{
                for (int c = 0; c < C; ++c) {{
                    data[n*stride_n + h*stride_h + w*stride_w +c] = n*(H*W*C) + h*(W*C) + w*C + c;
                }}
            }}
        }}
    }}
    StrideTensor tensor(data);
    for (auto n : tensor.N) {{
        for (auto h : tensor.H) {{
            for (auto w : tensor.W) {{
                for (auto c : tensor.C) {{
                    EXPECT_EQ(*tensor.n(n).h(h).w(w).c(c), n.get()*(H*W*C) + h.get()*(W*C) + w.get()*C + c.get());
                    EXPECT_EQ(*tensor[n][h][w][c], n.get()*(H*W*C) + h.get()*(W*C) + w.get()*C + c.get());
                }}
            }}
        }}
    }}
    EXPECT_EQ(StrideTensor::size, size);
    EXPECT_EQ(StrideTensor::num_bytes, static_cast<int>(num_bytes));
}}
"""
    return test_code


@_cpp_test
def _test_checkerboard_tensor():
    c16 = 8
    r = 16
    c = 2

    specs = [
        gen.Tensor(
            "CheckerboardTensor",
            gen.dtype.float,
            dict(c16=c16, checkers=gen.CheckerboardIndex(r=16, c=c)),
            constant=True,
        ),
    ]
    generated_code = gen.generate(specs, namespace="CheckerboardTensor_GenCode")

    test_code = f"""

{generated_code}

UTEST(CheckerboardTensor, offset_from_tensor)
{{
    using namespace CheckerboardTensor_GenCode;
    constexpr int C16 = {c16};
    constexpr int R = {r};
    constexpr int C = {c};
    constexpr int size = C16 * R * C;
    constexpr size_t num_bytes = sizeof(float) * size;

    float data[C16 * R * C];
    for (int c16 = 0; c16 < C16; ++c16) {{
        for (int r = 0; r < R; ++r) {{
            for (int c = 0; c < C; ++c) {{
                data[c16 * R * C + r * C + c] = c16 * R * C + r * C + c;
            }}
        }}
    }}

    for (int c16 = 0; c16 < C16; ++c16) {{
        for (int r = 0; r < R; ++r) {{
            for (int c = 0; c < C; ++c) {{
                EXPECT_EQ(
                    *CheckerboardTensor(data).c16(c16).checkers(r, c),
                    data[c16 * R * C + spio::CheckerboardIndex<8>::offset(r, c)]
            );
            }}
        }}
    }}
}}
    """
    return test_code


@_cpp_test
def _test_fragment_index():

    specs = [
        gen.Dim("lane"),
        gen.FragmentIndex("A", gen.FragmentType.M16_K16_F16_A, "r", "s"),
        gen.FragmentIndex("B", gen.FragmentType.N16_K16_F16_B, "s", "t"),
        gen.FragmentIndex("C", gen.FragmentType.M16_N16_F32_C, "r", "s"),
        gen.FragmentIndex("B2", gen.FragmentType.N8_K8_F16_B, "s", "t"),
    ]
    generated_code = gen.generate(specs, namespace="FragmentIndex_GenCode")
    test_code = f"""
{generated_code}

UTEST(FragmentIndex, MMA_M16_K16_F16_A)
{{
    using namespace FragmentIndex_GenCode;
    constexpr LANE_Dim lanes = 32;
    for (auto lane : lanes) {{
        for (int idx = 0; idx < A::size(); ++idx) {{
            EXPECT_TRUE(A(lane).r(idx) == R_Dim(spio::MMA_A_88_F16_Index(lane.get()).i(idx)));
            EXPECT_TRUE(( A(lane).s2(idx) == spio::Fold<S_Dim, 2>(spio::MMA_A_88_F16_Index(lane.get()).k2(idx)) ));
            EXPECT_TRUE(( A(lane).s8(idx) == spio::Fold<S_Dim, 8>(spio::MMA_A_88_F16_Index(lane.get()).k8(idx)) ));
            EXPECT_TRUE(( A(lane).s2m4() == spio::Fold<S_Dim, 2>(spio::MMA_A_88_F16_Index(lane.get()).k2m4()) ));
        }}
    }}
}}

UTEST(FragmentIndex, MMA_N16_K16_F16_B)
{{
    using namespace FragmentIndex_GenCode;
    constexpr LANE_Dim lanes = 32;
    for (auto lane : lanes) {{
        for (int idx = 0; idx < B::size(); ++idx) {{
            EXPECT_TRUE(B(lane).t(idx) == T_Dim(spio::MMA_B_88_F16_Index(lane.get()).j(idx)));
            EXPECT_TRUE(( B(lane).s2(idx) == spio::Fold<S_Dim, 2>(spio::MMA_B_88_F16_Index(lane.get()).k2(idx)) ));
            EXPECT_TRUE(( B(lane).s8(idx) == spio::Fold<S_Dim, 8>(spio::MMA_B_88_F16_Index(lane.get()).k8(idx)) ));
            EXPECT_TRUE(( B(lane).s2m4() == spio::Fold<S_Dim, 2>(spio::MMA_B_88_F16_Index(lane.get()).k2m4()) ));
        }}
    }}
}}

UTEST(FragmentIndex, MMA_N8_K8_F16_B)
{{
    using namespace FragmentIndex_GenCode;
    constexpr LANE_Dim lanes = 32;
    for (auto lane : lanes) {{
        for (int idx = 0; idx < B2::size(); ++idx) {{
            EXPECT_TRUE(B2(lane).t(idx) == T_Dim(spio::MMA_B_88_F16_Index(lane.get()).j(idx)));
            EXPECT_TRUE(( B2(lane).s2(idx) == spio::Fold<S_Dim, 2>(spio::MMA_B_88_F16_Index(lane.get()).k2(idx)) ));
            EXPECT_TRUE(( B2(lane).s8(idx) == spio::Fold<S_Dim, 8>(spio::MMA_B_88_F16_Index(lane.get()).k8(idx)) ));
            EXPECT_TRUE(( B2(lane).s2m4() == spio::Fold<S_Dim, 2>(spio::MMA_B_88_F16_Index(lane.get()).k2m4()) ));
        }}
    }}
}}

UTEST(FragmentIndex, MMA_M16_N16_F32_C)
{{
    using namespace FragmentIndex_GenCode;
    constexpr LANE_Dim lanes = 32;
    for (auto lane : lanes) {{
        for (int idx = 0; idx < C::size(); ++idx) {{
            EXPECT_TRUE(C(lane).r(idx) == R_Dim(spio::MMA_C_88_F32_Index(lane.get()).i(idx)));
            EXPECT_TRUE(( C(lane).s2(idx) == spio::Fold<S_Dim, 2>(spio::MMA_C_88_F32_Index(lane.get()).j2(idx)) ));
            EXPECT_TRUE(( C(lane).s8(idx) == spio::Fold<S_Dim, 8>(spio::MMA_C_88_F32_Index(lane.get()).j8(idx)) ));
            EXPECT_TRUE(( C(lane).s2m4() == spio::Fold<S_Dim, 2>(spio::MMA_C_88_F32_Index(lane.get()).j2m4()) ));
        }}
    }}
}}
"""
    return test_code


@_cpp_test
def _test_fragment_load_index():
    specs = [
        gen.Dim("lane"),
        gen.FragmentLoadIndex("Input", gen.FragmentType.M16_K16_F16_A, "x", "c"),
        gen.FragmentLoadIndex("Weights", gen.FragmentType.N8_K16_F16_B, "c", "k"),
    ]
    generated_code = gen.generate(specs, namespace="FragmentLoadIndex_GenCode")
    test_code = f"""
{generated_code}

UTEST(FragmentLoadIndex, MMA_M16_K16_F16_A)
{{
    using namespace FragmentLoadIndex_GenCode;
    constexpr LANE_Dim lanes = 32;
    for (auto lane : lanes) {{
        EXPECT_TRUE(Input(lane).x() == X_Dim( spio::MMA_A_M16_K16_F16_LoadIndex(lane.get()).i()) );
        auto a = spio::Fold<C_Dim, 8>( spio::MMA_A_M16_K16_F16_LoadIndex(lane.get()).k8());
        EXPECT_TRUE(Input(lane).c8() ==  a);
    }}

    for (auto lane : lanes) {{
        auto b = spio::Fold<C_Dim, 8>( spio::MMA_B_N8_K16_F16_LoadIndex(lane.get()).k8());
        EXPECT_TRUE(Weights(lane).c8() == b);
        EXPECT_TRUE(Weights(lane).k() == K_Dim( spio::MMA_B_N8_K16_F16_LoadIndex(lane.get()).j()) );
     }}
}}
"""
    return test_code


def _compile_cpp_tests(extra_cpp_test_files=None):
    """Compile C++ tests with NVCC."""
    if extra_cpp_test_files is None:
        extra_cpp_test_files = []
    includes = [
        importlib_resources_files("spio.include"),
        importlib_resources_files("spio.src_tests"),
    ]
    sources = [
        importlib_resources_files("spio.src_tests") / src for src in CPP_SOURCES
    ] + extra_cpp_test_files
    includes = [str(include) for include in includes]
    return spio.compiler.compile_with_nvcc(sources=sources, includes=includes, run=True)
